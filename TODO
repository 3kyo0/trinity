* Add a parameter to bias the randomness passed to length parameters.
  Right now it's hardwired to return 16 bit 70% of the time.
  (and 32bit in the 64bit path)

* Argument order bug.
  ./trinity --mode=random --32bit -c mprotect  doesn't see the -c
  ./trinity --mode=random -c mprotect --32bit does.

* Make -k use random kernel addresses (from System.map ?)

* --oneshot
  ./trinity --oneshot sys_futex -1,0x40000000,1,2,3,4

* --info sys_open
   i386:   5
   x86-64: 239
   ppc64:  5

* Check registers on return 
  - Set regs that should be preserved across syscalls to a known value, and check
    on return whether any of them got clobbered.
  - Check for corruption patterns (LIST_DEBUG, SLAB_POISON)
  - in 32bit mode check that there isn't anything in the upper bits.

* Improve logging.
  - writelog is really crap.  It would be better if we just had a print_and_log
    varargs function that did both the printf to stdout and the logging so
    that we didn't need to duplicate output strings. (Though it would need to
    strip out the ansi colour codes for the logfile output).
  - when multi-threaded, it may make more sense to have a logfile per thread.
  - is the fflush at the end enough? do we need to fsync ?

* --nrsyscalls (set NR_SYSCALLS)
  Hmm, maybe --kver=2.6.9 to set the nr to the nr syscalls in that rev ?
  This would require a database of per-kernel syscall numbers.
  It would also be incorrect with any enterprise kernels which backport syscalls.
  Maybe we could do a probe first, and adjust based on the -ENOSYS's we get back.

* if we get -EPERM from a syscalls we know checks for CAP_SYS_ADMIN early,
  don't bother retrying it.

* Due to forking of child processes, things like mmap/mprotect etc
  don't do anything to affect future calls.
  - Add a new syscall flag 'DONTFORK' for mm related syscalls ?
  - Or possibly a --vm mode to only call VM related calls.

* Xen dom0 hypercalls ?

* Other arch support. S390? fully native PPC64? (PPC64 currently requires 32-bit glibc-kernheaders)

* some of the syscalls allocate a chunk of memory. When we pass garbage, this could add up to
  huge amounts of ram, which then mean we trigger the oom killer.
  This isn't really desirable (nor is it a bug). We should possibly set some ulimits before
  running the test harness.
  (If we want to be really clever, somehow track the allocations, and then free them N syscalls later)

* Ability to pass a list of comma separated syscalls on the command-line.

* syscall groups.
  --group=vm  for example would only call memory management related syscalls.

* run tests in different namespaces, personalities.

* fork N threads.

* mprotect the buffers we allocate that get passed to the kernel.

* make a list of filenames during fd_setup, so that we can pass one at random
  when sanitising open()

