* BUG: -c socketcall calls the wrong syscall. Looks like syscalltable confusion.

* generate overlapping addresses/lengths.

* -b is broken. We need to do the same number of rand() calls we did in
  the calls we're skipping, which is pretty much impossible without
  doing them when we're using -i.  Maybe just be silent until we get
  to the point of -b ?

* Store a field in the syscall definition on when it was added upstream.
  This will allow for things like "just fuzz syscalls added since 2.6.32"
  It won't be much use on kernels that have them backported, but that's
  not a big deal. We could do a ENOSYS test.

* Arch specific TODO
  x86-64: Build both a 64bit and a 32bit executable.
  ia64: build syscalls/ia64/

* sanitise_sync_file_range is bullshit

* -F occasionally wedges the process.  It still runs, but there's no output.
  Not entirely sure what's going on yet. Could be just another syscall that
  we need to mark AVOID.  The alarm doesn't go off because the process is
  still running.

* clock_nanosleep can wedge for a really long time without the alarm going off.
  either figure out if we can limit it, or mark it AVOID

* --nolog
* --ignore-socketcache
* --monochrome

* Check out how kerneloops notices an oops.
  If it's something in proc/sys check it after each syscall

* Destructors
  Need to store the result of syscalls on success, so that if we allocated
  something, we can deallocate it when we're done. (Perhaps delay the
  deallocation N syscalls?)

* Struct fabrication
  Some syscalls are rejecting immediately because we aren't passing them
  a struct they're expecting. So allocate and fake one. Then throw it
  away in the destructor.

* Add a parameter to bias the randomness passed to length parameters.
  Right now it's hardwired to return 16 bit 70% of the time.
  (and 32bit in the 64bit path)

* Add a parameter for the dir/file randomness bias

* Argument order bug.
  ./trinity --mode=random --32bit -c mprotect  doesn't see the -c
  ./trinity --mode=random -c mprotect --32bit does.

* Make -k use random kernel addresses (from System.map ?)

* --oneshot
  ./trinity --oneshot sys_futex -1,0x40000000,1,2,3,4

* --info sys_open
   i386:   5
   x86-64: 239
   ppc64:  5

* Check registers on return 
  - Set regs that should be preserved across syscalls to a known value, and check
    on return whether any of them got clobbered.
  - Check for corruption patterns (LIST_DEBUG, SLAB_POISON)
  - in 32bit mode check that there isn't anything in the upper bits.

* --32bit still passes 64bit addresses.

* --nrsyscalls (set NR_SYSCALLS)
  Hmm, maybe --kver=2.6.9 to set the nr to the nr syscalls in that rev ?
  This would require a database of per-kernel syscall numbers.
  It would also be incorrect with any enterprise kernels which backport syscalls.
  Maybe we could do a probe first, and adjust based on the -ENOSYS's we get back.

* Xen dom0 hypercalls ?

* Other arch support. S390? fully native PPC64? (PPC64 currently requires 32-bit glibc-kernheaders)

* some of the syscalls allocate a chunk of memory. When we pass garbage, this could add up to
  huge amounts of ram, which then mean we trigger the oom killer.
  This isn't really desirable (nor is it a bug). We should possibly set some ulimits before
  running the test harness.
  (If we want to be really clever, somehow track the allocations, and then free them N syscalls later)

* Ability to pass a list of comma separated syscalls on the command-line.

* syscall groups.
  --group=vm  for example would only call memory management related syscalls.
  (Mark syscalls with SYSCALL_VM in flags

* run tests in different namespaces, personalities.

* fork N threads.

* mprotect the buffers we allocate that get passed to the kernel.

* make a list of filenames during fd_setup, so that we can pass one at random
  when sanitising open()

