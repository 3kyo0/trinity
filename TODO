* Struct fabrication
  Some syscalls are rejecting immediately because we aren't passing them
  a struct they're expecting. This requires us to create a few new methods.
  .constructor:
	Before we do the syscall, we need a constructor method
	to allocate and fake one.
  .destructor:
	Likewise, we need destructors to prevent resource leaks.

  On return from the syscall, we don't call the destructor immediately.
  We pick a small random number, and do N other syscalls before we do the destruction.
  This requires us to create a list of work to be done later, along with a pointer
  to any allocated data.
  .post:
	Recieves the retval from the syscall, and handles appropriately.
	Pick a small random number for the lifetime of the resource
	Store any allocated resources in the 'to be destroyed' list.


* generate overlapping addresses/lengths.

* There are a few syscalls with duplicate '64' variants.
  They take the same arguments, and vary only in name.
  Two possibilities.
  1. what I did for fcntl[64] in 22b4b44ececaf59f9178f52788e3bcfe92535574
  2. leave the dupes, just for the sake of getting the ->name right.

* -b is broken. We need to do the same number of rand() calls we did in
  the calls we're skipping, which is pretty much impossible without
  doing them when we're using -i.  Maybe just be silent until we get
  to the point of -b ?

* Store a field in the syscall definition on when it was added upstream.
  This will allow for things like "just fuzz syscalls added since 2.6.32"
  It won't be much use on kernels that have them backported, but that's
  not a big deal. We could do a ENOSYS test.

* Rethink the parent/child model.
  - Fork multiple fuzzers.
  - Store the pids of the children, and hand them out in ARG_PID

* Arch specific TODO
  x86-64: Build both a 64bit and a 32bit executable.
  *: Move arch specific syscalls into syscalls/arch/

* sanitise_sync_file_range is bullshit

* -F occasionally wedges the process.  It still runs, but there's no output.
  Not entirely sure what's going on yet. Could be just another syscall that
  we need to mark AVOID.  The alarm doesn't go off because the process is
  still running.

* Some syscalls can wedge for a really long time without the alarm going off.
  either figure out if we can limit the time taken, or mark them AVOID.
  (clock_nanosleep for eg.) Possibly also futex, though earlier hangs seen
  there may have been fixed in e6780f7243eddb133cc20ec37fa69317c218b709

* --nolog
* --ignore-socketcache
* --monochrome

* On return from a syscall, check padding between struct members is zeroed.

* Add a parameter to bias the randomness passed to length parameters.
  Right now it's hardwired to return 16 bit 70% of the time.
  (and 32bit in the 64bit path)

* Add a parameter for the dir/file randomness bias

* Make -k use random kernel addresses (from System.map ?)

* --oneshot
  ./trinity --oneshot sys_futex -1,0x40000000,1,2,3,4

* --info sys_open
   i386:   5
   x86-64: 239
   ppc64:  5

* Check registers on return 
  - Set regs that should be preserved across syscalls to a known value, and check
    on return whether any of them got clobbered.
  - Check for corruption patterns (LIST_DEBUG, SLAB_POISON)

* Xen dom0 hypercalls ?

* Other arch support. S390? fully native PPC64? (PPC64 currently requires 32-bit glibc-kernheaders)

* some of the syscalls allocate a chunk of memory. When we pass garbage, this could add up to
  huge amounts of ram, which then mean we trigger the oom killer.
  This isn't really desirable (nor is it a bug). We should possibly set some ulimits before
  running the test harness.
  (If we want to be really clever, somehow track the allocations, and then free them N syscalls later)

* Ability to pass a list of comma separated syscalls on the command-line.

* syscall groups.
  --group=vm  for example would only call memory management related syscalls.
  (Mark syscalls with SYSCALL_VM in flags

* run tests in different namespaces, personalities.

* fork N threads.

* Safety checks for buffers we pass to the kernel
- mprotect them
- add guard pages before/after, and add poison to be checked on return.

* make a list of filenames during fd_setup, so that we can pass one at random
  when sanitising open()

* --blacklist=open,read,write

* Log timestamps along with each syscall.
