* Convert the syscall lists for all archs over to the new-style (see x86-64)
  The lack of .num_args probably breaks scrashme on those archs right now.

* --mode=rotate is currently a bit broken.
  Because we force all syscalls to be 6-args in that mode, the childs segv
  when they try to print argument names.  This always was a hack anyway,
  so come up with something better.

* Make -k use random kernel addresses (from System.map ?)

* --oneshot
  ./scrashme --oneshot sys_futex -1,0x40000000,1,2,3,4

* --info sys_open
   i386:   5
   x86-64: 239
   ppc64:  5

* Check registers on return 
  - Set regs that should be preserved across syscalls to a known value, and check
    on return whether any of them got clobbered.
  - Check for corruption patterns (LIST_DEBUG, SLAB_POISON)

* Improve logging.
  - writelog is really crap.  It would be better if we just had a print_and_log
    varargs function that did both the printf to stdout and the logging so
    that we didn't need to duplicate output strings. (Though it would need to
    strip out the ansi colour codes for the logfile output).
  - when multi-threaded, it may make more sense to have a logfile per thread.
  - is the fflush at the end enough? do we need to fsync ?

* --nrsyscalls (set NR_SYSCALLS)
  Hmm, maybe --kver=2.6.9 to set the nr to the nr syscalls in that rev ?

* if we get -EPERM from a syscalls we know checks for CAP_SYS_ADMIN early,
  don't bother retrying it.

* add a switch to use 32bit syscall entry point on x86-64
  This will require us to use assembly instead of syscall() again.

* Due to forking of child processes, things like mmap/mprotect etc
  don't do anything to affect future calls.
  - Add a new syscall flag 'DONTFORK' for mm related syscalls ?
  - Or possibly a --vm mode to only call VM related calls.

* Xen dom0 hypercalls ?

* Other arch support. S390? fully native PPC64? (PPC64 currently requires 32-bit glibc-kernheaders)

* some of the syscalls allocate a chunk of memory. When we pass garbage, this could add up to
  huge amounts of ram, which then mean we trigger the oom killer.
  This isn't really desirable (nor is it a bug). We should possibly set some ulimits before
  running the test harness.
  (If we want to be really clever, somehow track the allocations, and then free them N syscalls later)

* Ability to pass a list of comma separated syscalls on the command-line.

* syscall groups.
  --group=vm  for example would only call memory management related syscalls.

* run tests in different namespaces, personalities.

* fork N threads.

* check x86-64 32bit syscalltable vs real 32bit syscalltable

* flags for reserved syscalls (tux, vserver etc)

* mprotect the buffers we allocate that get passed to the kernel.

