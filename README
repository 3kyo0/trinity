Trinity v1.0

	"After the initial euphoria of witnessing the explosion had passed, test
	 director Kenneth Bainbridge commented to Los Alamos director J. Robert
	 Oppenheimer, "Now we are all sons of bitches."   Oppenheimer later stated
	 that while watching the test he was reminded of a line from the Hindu
	 scripture the Bhagavad Gita:

		Now I am become Death, the destroyer of worlds."



Warning: This program may seriously corrupt your files, including any of those
that may be writable on mounted network file shares.  It may create network
packets that may cause disruption on your local network.
Run at your own risk.


System call fuzzers aren't a particularly new idea.   As far back as 1991,
people have written apps that bomb syscall inputs with garbage data,
that have had a variety of success in crashing assorted operating systems.

After fixing the obvious dumb bugs however, a majority of the time
these calls will just by rejected by the kernel very near the beginning
of their function entry point as basic parameter validation is performed.

Trinity is a system call fuzzer which employs some basic intelligence
techniques (though when run without any arguments it too is dumb as a rock).

The intelligence features include:

- If a system call expects a certain datatype as an argument
  (for example a file descriptor) it gets passed one.
  This is the reason for the slow initial startup, as it generates a
  list of fd's of files it can read from /sys, /proc and /dev
  and then supplements this with fd's for various network protocol sockets.
  (Information on which protocols succeed/fail is cached on the first run,
   greatly increasing the speed of subsequent runs).

- If a system call only accepts certain values as an argument,
  (for example a 'flags' field), trinity has a list of all the valid
  flags that may be passed.
  Just to throw a spanner in the works, occasionally, it will bitflip
  one of the flags, just to make things more interesting.

- If a system call only takes a range of values, the random value
  passed is ensured to fit within that range.


Trinity logs it's output to a file, and fsync's the file before
it actually makes the system call. This way, should you trigger something
which panics the kernel, you should be able to find out exactly what
happened by examining the log.

There is a test harness provided (test.sh), which runs trinity in various modes,
and takes care of things like cpu affinity, and makes sure it runs from the
tmp directory. (Handy for cleaning up any garbage named files; just rm -rf tmp afterwards)

######### options ###############################################

The first option that trinity has is '--mode=', which must
be one of the following..

'random'
 Good for stress testing, just does zillions of random junk syscalls.
 -sN: use N as random seed.  (Omitting this uses time of day as a seed).
 Adding '--bruteforce' (or -B) to the command line will keep retrying the
 same syscall with random parameters until it succeeds. This option needs -i
 to also be passed. (described below)
 Until more of the -i option gets fleshed out, this will cause many syscalls
 to 'stick', due to random parameters being repeatedly rejected.
 Because of this, currently, bruteforce will only retry the same syscall 100 times.

'rotate'
 This will call every syscall sequentially, with a specific value in a register,
 and will "rotate" it through all possible register combinations.
 For example, the values of the registers being passed change thusly over time..
  random, random, random, random, random, VALUE
  random, random, random, random, VALUE, random
  random, random, random, random, VALUE, VALUE 
  random, random, random, VALUE, random, random
  etc.. 

 until it eventually gets to calling with the value in all registers.
 (This option usually used with -z, see below)

 This mode operates internally as if every syscall has 6 args.  Due to the way
 that the value 'travels' through the registers, a syscall with 3 args
 for example has to wait until the value has travelled through the 4th, 5th and 6th
 registers before it appears, even though those registers never get passed
 to the syscall.


For random and rotate modes, there exist a number of further options that
define what kinds of values are passed in registers to the syscalls.

structures:
  -Sxx:  pass a struct filled with any hex value (xx).
  This calls syscalls with a pointer to a struct that is filled with hex xx
  as arguments.
 or
  -Sr:  pass struct filled with random byte values.
  As above, but with a struct filled with random chars.
 In all cases, the structure passed is the size of one page.
 (Ie, 4KB on most archs)


 -z:  Use all zeros as register parameters.
This calls every syscall with zeros in each of the registers in turn, in
every possible combination, with random junk in the other registers.
Useful for testing for missing NULL checks.



There also exist some options which apply to all available modes.

-bN: begin at offset N.
Useful for reproducing bugs that start after a certain # of runs.

-cN: do syscall N with random inputs.
Good for concentrating on a certain syscall, if for eg, you just added one.

-i: Use Intelligent parameters.
Given a vast number of syscalls do some checking, chances are a majority
of the calls will get something like -EINVAL back.  This option passes
some almost sensible looking parameters to defeat the simplest checks.
This requires a .sanitise method for each syscall, and right now,
hardly any of the syscalls provide this.


Other useful arguments:
--list will dump all available syscalls, and their syscall number.

#######################################################################

Examples:
./trinity -c splice -r -i
Stress test the splice syscall, with random parameters, but sanitise
the passed params so they look almost sensible.


######### Links to similar projects ####################################

= tsys - 1991.
  http://groups.google.com/groups?q=syscall+crashme&hl=en&lr=&ie=UTF-8&selm=1991Sep20.232550.5013%40smsc.sony.com&rnum=1

= iknowthis
  http://iknowthis.googlecode.com
  Fuzzer by Tavis Ormandy with very similar goals to this project.

= sysfuzz
  basic fuzzer by Ilja van Sprundel
  mentioned in http://events.ccc.de/congress/2005/fahrplan/attachments/683-slides_fuzzing.pdf
  http://leetupload.com/dbindex2/index.php?dir=Linux/&file=sysfuzz.tar.gz

= xnufuzz
  https://github.com/fintler/xnufuzz/tree/
  basic fuzzer for XNU.  Looks to be based on Ilja's sysfuzz.

= kg_crashme / ak_crashme / dj_crashme
  Kurt Garloff wrote a fuzzer similar to Ilja's sysfuzz in 2003.
  The ak / dj variants were improvements added by Andi Kleen, and Dave Jones.
